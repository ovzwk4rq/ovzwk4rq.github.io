---
layout: post
title: 힙
---
```
class Heap {
    constructor(prior) {
        this.arr = [ null ];
        this.prior = prior;
    }
    
    size() {
        return this.arr.length - 1;
    }
    
    top() {
        return this.arr[1];
    }
    
    push(val) {
        this.arr.push(val);
        let i = this.arr.length - 1;
        let j = Math.floor(i / 2);
        while (i > 1 && this.prior(this.arr[i], this.arr[j])) {
            let tmp = this.arr[i];
            this.arr[i] = this.arr[j];
            this.arr[j] = tmp;
            i = j;
            j = Math.floor(i / 2);
        }
    }
    
    pop() {
        const top = this.arr[1];	
        this.arr[1] = this.arr[this.arr.length - 1];
        this.arr.pop();
        let i = 1;
        let j, k, p;

        function setjkp() {
            j = 2 * i;
            k = 2 * i + 1;
            p = i;
            if (j < this.arr.length && this.prior(this.arr[j], this.arr[p]))
                p = j;
            if (k < this.arr.length && this.prior(this.arr[k], this.arr[p]))
                p = k;
        }

        setjkp.call(this);
        while (p !== i) {
            let tmp = this.arr[i];
            this.arr[i] = this.arr[p];
            this.arr[p] = tmp;
            i = p;
            setjkp.call(this);
        }
        return top;
    }
}
```
어떤 부모-자식 쌍을 골라도 부모가 자식보다 우선하거나 같은 트리를 안정적인 트리라고 명명.  

안정적인 트리에 노드 하나를 추가하고도 안정적인 트리가 되도록 만들어야함.  
다음 성질들을 생각.  
1. 어떠한 노드 i를 제외한 모든 부모가 있는 노드들이 자신의 부모와 순서가 맞음.  
2. i의 부모가 있다면 i의 부모와 i의 모든 자식들이 순서가 맞음.  
3. i의 부모가 있고, i는 i의 부모와 순서가 맞지 않음.  

새로운 노드가 리프 노드가 되도록 추가한다면, 만들어진 트리는 성질 1, 2, 3을 만족함.  
성질 1을 만족하고 3은 만족하지 않는 트리가 안정적인 트리임.  
성질 1, 2, 3을 만족하는 트리 T에서 i와 i의 부모의 값을 바꿔서 만든 트리 T'을 생각.  
T'이 성질 1, 2를 만족함을 증명한다면, 반복문을 통해 안정적인 트리를 만들 수 있음.  
성질 1을 확인하려면 T'의 모든 부모-자식 관계가 T와 어떻게 다른지 관찰해야 함.  
i의 부모를 j라고 명명.  
i와 j를 포함하지 않는 부모-자식 관계는 T와 T'에서 같으므로 순서가 맞음.  
i나 j를 포함하는 부모-자식 관계는 다음 4가지중 하나임.  
1. i와 그 자식의 관계  
2. j와 i의 관계  
3. j와 i의 형제의 관계  
4. j와 그 부모의 관계  

T'의 1번 관계는 T에서의 j와 i의 자식의 관계와 같으므로 순서가 맞음.  
T'의 2번 관계는 T에서의 2번 관계와 반대이므로 순서가 맞음.  
T'의 3번 관계는 T에서의 i와 i의 형제들의 관계임.  
T에서 j는 i의 형제들보다 우선하거나 같고 i는 j보다 우선하므로, i는 i의 형제들보다 우선함.  
따라서 T'의 3번 관계는 순서가 맞음.  
따라서 T'에서는 j가 i의 역할을 할때 1번 성질을 만족함.  
성질 2를 확인하려면, T'의 조부모-손주 관계 중 중간을 잇는 노드가 j인 관계들이 T와 어떻게 다른지 봐야함.  
그러한 관계는 i를 포함하거나 포함하지 않음.  
i를 포함하지 않는 관계는 T와 T'이 같으므로 순서가 맞음.  
i를 포함하는 관계는 T에서 j와 그 부모의 관계와 같으므로 순서가 맞음.  
따라서 T'에서는 j가 i의 역할을 할때 2번 성질도 만족함.  

안정적인 트리에서 루트 노드와 같은 값을 가진 노드가 하나 없어진 안정적인 트리를 만들어야함.  
다음 성질들을 생각.  
1. 어떠한 노드 i를 부모로 갖지 않는 모든 부모-자식 관계의 순서가 맞음.  
2. i가 중간에 있는 모든 조부모-손주 관계의 순서가 맞음.  
3. i를 부모로 가지면서 순서가 맞지 않는 부모-자식 관계가 존재함.  

루트 노드가 어떤 리프 노드와 같은 값을 갖게 한 후, 그 리프 노드를 제거해서 만든 트리를 생각.  
그 트리는 성질 1, 2, 3을 만족.  
성질 1을 만족하고 3은 만족하지 않는 트리가 안정적인 트리임.  
성질 1, 2, 3을 만족하는 트리 T를 생각.  
T에서 i와 순서가 맞지 않는 i의 자식들 중 가장 우선순위가 높은 자식을 p라고 명명.  
T에서 i와 p의 값을 바꿔서 만든 트리 T'을 생각.  
T'이 성질 1, 2를 만족함을 증명한다면, 반복문을 통해 안정적인 트리를 만들 수 있음.  
성질 1을 확인하려면 T'의 모든 부모-자식 관계가 T와 어떻게 다른지 관찰해야 함.  
i와 p를 포함하지 않는 부모-자식 관계는 T와 T'에서 같으므로 순서가 맞음.  
i나 p를 포함하는 부모-자식 관계는 다음 4가지중 하나임.  
1. i와 그 부모의 관계  
2. i와 p의 관계  
3. i와 p의 형제의 관계  
4. p와 그 자식의 관계  

T' 의 1번 관계는 T에서의 i가 중간에 있는 조부모-손주 관계이므로 순서가 맞음.  
T' 의 2번 관계는 T에서의 2번 관계와 반대이므로 순서가 맞음.  
T' 의 3번 관계는 T에서 p와 p의 형제들의 관계임.  
T에서 p는 i보다 우선하고 i는 p의 형제들보다 우선하거나 같으므로, p는 p의 형제들보다 우선함.  
따라서 T'의 3번 관계는 순서가 맞음.  
따라서 T'에서 p가 i의 역할을 할때 1번 성질을 만족함.  
성질 2를 확인하려면, 성질 2에서 말하는 관계들이 T와 T'에서 어떻게 다른지 봐야함.  
그러한 관계는 p를 포함하거나 포함하지 않음.  
p를 포함하지 않는 관계는 T와 T'이 같으므로 순서가 맞음.  
p를 포함하는 관계는 T에서 i와 그 부모의 관계와 같으므로 순서가 맞음.  
따라서 T'에서 p가 i의 역할을 할때 2번 성질도 만족함.  

트리가 항상 완전 이진 트리를 유지하도록 만들 수 있음.  
그렇게 하면 삽입/삭제의 시간복잡도가 O(log(n))으로 유지됨.  
그렇게 하려면 위의 과정들에서 임의의 리프 노드 대신 마지막 노드를 추가/삭제 해야함.  
완전 이진 트리는 노드에 순서를 부여하기가 쉬우므로(글 읽는 순서) 배열로 표현하기 쉬움.  
루트 노드에 1번을 대응시켰을 때 노드들의 부모/자식을 계산하기가 제일 쉬움.  
그때 i번 노드의 자식은 2 * i 번과 2 * i + 1 번이 됨.  
