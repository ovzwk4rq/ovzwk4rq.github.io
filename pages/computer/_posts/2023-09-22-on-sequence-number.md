---
layout: post
title: 순서번호에 관한 생각
---

이 글은 James Kurose와 Keith Ross의 책 Computer Networking: A Top Down Approach 6판의 3.4절, Principles of Reliable Data Transfer를 읽고 이해가 되지 않는 부분을 고민한 결과를 정리한 것이다.

나는 3.4.2절, Pipelined Reliable Data Transfer Protocols부터 이해가 안되기 시작했다. 책에서 프로토콜의 동작 원리를 설명할 때에는 순서번호로 '진짜' 정수, 즉 표현할 수 있는 범위에 제한이 없는 정수를 사용해서 설명한 후, 그 뒤에 '물론 실제로는 패킷에 유한한 비트만 담을 수 있기 때문에 범위가 제한된 정수에 모듈로 연산을 해서 사용한다'는 식의 설명을 덧붙였는데, 범위가 제한된 정수를 이용해도 프로토콜이 잘 작동한다는 것을 증명할 수가 없었다.

오랜 고민 끝에, '범위가 제한된 정수를 이용한다'는 생각을 '진짜 정수를 범위가 제한된 정수를 이용해 표현한다'는 생각으로 바꿨더니 쉽게 해결이 되었다.

앞으로의 설명에서 한가지 가정해야 할 것은, 보낸 패킷의 순서가 바뀌어서 도착하는 일은 없다는 것이다. 비록 실제와 다르지만, 책에서도 이것을 가정하고 설명을 진행했기 때문에 일단 나도 그 가정을 따라가려고 한다.

먼저 Go-Back-N 프로토콜을 살펴보자.

n번째 메시지와 그 순서번호인 n이 들어있는 패킷을 n번째 패킷이라고 부르기로 하면, 보내는 쪽에서는 base라는 변수를 가지고 있어서 base번째부터 base+N-1번째까지의 패킷을 계속 반복해서 보낸다. 그러는 도중 깨끗한(변경되지 않은) ack를 받으면 base의 값을 ack의 값으로 바꾼다. base는 당연히 0부터 시작한다.

받는 쪽에서는 want라는 변수를 가지고 있어서, 순서번호가 want와 같은 깨끗한 패킷이 오면 그 패킷의 메시지를 받아들이고 want의 값을 1 증가시킨다. 그러는 도중 아무때나 ack를 보내는데, 그때 ack에 want의 값을 넣어서 보낸다. want도 당연히 0부터 시작한다.

받는 쪽에서 깨끗한 패킷을 받은 상황을 생각해 보자. 그 패킷의 순서번호를 seq, 그 시점에서 want의 값을 want라고 한다면, `want-N <= seq < want+N`이 성립한다. 그 이유는 다음과 같다.

* seq가 음수일 수는 없으므로 want가 0이라면 `want-N <= seq`가 성립한다.
* want가 0이 아니라면, 순서번호가 want-1인 패킷을 받은 적이 있다는 뜻이고, 그 패킷을 보낼 때 base의 값은 want-N보다 크거나 같았다는 뜻이다. 그런데 base의 값은 절대 감소하지 않으므로, 지금 받은 패킷은 base의 값이 want-N보다 크거나 같을 때 보내졌다는 뜻이다. 따라서 want가 0이 아닐 때도 `want-N <= seq`가 성립한다.
* base의 값은 want보다 컸던 적이 없으므로, 지금 받은 패킷은 무조건 base의 값이 want보다 작거나 같을 때 만들어졌다. 따라서 `seq < want+N`이 성립한다.

메시지의 순서번호의 역할은 want의 값과 같은지 다른지 비교되는 것밖에 없으므로, 그 역할만 잘 수행할 수 있으면 무엇이든지 순서번호의 표현이 될 수 있다. 이제 순서번호의 표현이 순서번호를 N+1로 나눈 나머지라고 하면, 순서번호의 표현이 want의 값을 N+1로 나눈 나머지와 같은지 다른지 확인함으로써 순서번호와 want의 값이 같은지 다른지를 확인할 수 있다. 왜냐하면 순서번호의 가능한 범위는 [want-N, want+N)인데, 이 안에 N+1로 나눈 나머지가 want의 값을 N+1로 나눈 나머지와 같은 값은 없으므로, 순서번호의 표현이 want의 값을 N+1로 나눈 나머지와 같다면 순서번호와 want의 값이 같은 것이고, 순서번호의 표현이 want의 값을 N+1로 나눈 나머지와 다르다면 당연히 순서번호와 want의 값도 다른 것이기 때문이다.

이제 보내는 쪽에서 깨끗한 ack를 받은 상황을 생각해 보자. 그 ack의 값을 ack, 그 시점에서 base의 값을 base라고 할 때, `base <= ack <= base+N` 이 성립한다. 그 이유는 다음과 같다.

* `base <= ack`가 성립한다는 것은 꽤나 당연하므로 따로 설명하지 않겠다.
* 만약 ack가 base+N보다 크다면, want의 값이 base+N보다 컸던 적이 있다는 뜻이고, 그것은 보낸 패킷의 순서번호가 base+N보다 크거나 같았던 적이 있다는 뜻이고, 그것은 base의 값이 base보다 컸던 적이 있다는 뜻인데, base는 절대 감소하지 않으므로 모순이다. 따라서 `ack <= base+N`이 성립한다.

ack의 값은 base의 값을 그 값으로 바꾸는데에만 쓰이므로, 그 역할만 잘 수행할 수 있으면 무엇이든지 ack의 표현이 될 수 있다. 이제 ack의 표현이 ack의 값을 N+1로 나눈 나머지라고 하면, ack의 표현과 base의 값을 보고 ack의 값을 알 수 있다. 왜냐하면 ack의 가능한 범위인 [base, base+N]안에 N+1로 나눈 나머지가 ack의 표현과 같은 값은 하나밖에 없을 것이기 때문이다. 그렇게 해서 알아낸 ack의 값을 base에 넣음으로써 base의 값을 ack의 값으로 바꿀 수 있다.

이제 Selective Repeat 프로토콜을 살펴보자.

보내는 쪽에서는 깨끗한 ack를 받으면 받은 값을 기록한다. 그러면서, 기록되지 않은 가장 작은 값을 base라고 하면, base번째부터 base+N-1번째까지의 패킷들을 반복해서 보낸다.

받는 쪽에서는 깨끗한 패킷을 받으면 그 패킷의 메시지를 무조건 받아들이고 ack에 그 패킷의 순서번호를 넣어서 보낸다. 그런데 이번엔 받아들이는 것이 Go-Back-N 프로토콜과는 다르다. '받아들인다'라는 행위를 받은 메시지들을 모아서 어떤 리스트를 만드는 것으로 생각한다면, Go-Back-N 프로토콜의 '받아들인다'는 리스트의 가장 뒤에 메시지를 추가하는 행위이고, Selective Repeat의 '받아들인다'는, 받은 패킷의 순서번호를 seq라고 하면,  리스트의 seq번째 원소가 그 메시지가 되도록 하는 행위이다.

받는 쪽에서 깨끗한 패킷을 받았는데 아직 메시지를 받아들이지는 않은 상황을 생각해 보자. 그 패킷의 순서번호를 seq, 받아들이지 않은 가장 작은 순서번호를 want라고 하면, `want-N <= seq < want+N`이 성립한다. 그 이유는 다음과 같다.

* `want-N <= seq`가 성립하는 이유는 Go-Back-N 프로토콜에서와 같다.
* 보내는 쪽에서 받은 ack들의 값의 집합은 받는 쪽에서 받은 패킷들의 순서번호의 집합의 부분집합이므로, `seq < want+N`이 성립하는 이유도 Go-Back-N 프로토콜에서와 같다.

보내는 쪽에서 깨끗한 ack를 받은 상황도 생각해 보자. 그 ack의 값을 ack라고 하면 `base-N <= ack < base+N`이 성립한다. 그 이유는 다음과 같다.

* ack가 음수일 수는 없으므로 base가 0이라면 `base-N <= ack`가 성립한다.
* base가 0이 아니라면, 값이 base-1인 ack를 받은 적이 있다는 뜻이므로 순서번호가 base-1인 패킷을 보낸 적이 있다는 뜻이고, 그때의 base의 값은 base-N보다 크거나 같았다는 뜻이다. base의 값이 감소하지 않으므로, 지금 받은 ack는 base의 값이 base-N보다 크거나 같을 때 보내진 패킷에 대한 응답이다. 따라서 base가 0이 아닐 때도 `base-N <= ack`가 성립한다.
* base의 값이 감소하지 않으므로, 순서번호가 base+N 이상인 패킷은 보내진 적이 없다. 따라서 `ack < base+N`이 성립한다.

순서번호와 ack모두 그 값을 2N으로 나눈 나머지가 그 표현이라고 하면, 각각의 가능한 범위인 [want-N, want+N)과 [base-N, base+N)에 2N으로 나눈 나머지가 그 표현과 같은 값이 없으므로 표현을 보고 값을 알 수 있다. 표현을 보고 값을 알 수 있으면 그 값이 하는 역할을 표현이 다 할 수 있다는 뜻이므로, 둘다 그렇게 표현이 가능하다.
